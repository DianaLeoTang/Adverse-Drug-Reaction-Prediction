# Modeling 2-DL 代码分析报告

## 项目概述
本项目使用深度学习（Deep Learning）模型进行药物不良反应（Adverse Drug Reaction, ADR）预测。代码包含数据预处理、特征工程、神经网络模型构建、超参数网格搜索和模型评估等完整流程。与Modeling 1-RF相比，本文件使用TensorFlow/Keras构建多层感知机（MLP）神经网络进行多标签分类。

---

## 代码详细分析

### Cell 0: 工作目录切换
```python
cd /work/farnoush
```
**解释**: 切换到指定工作目录 `/work/farnoush`，用于访问数据文件。

---

### Cell 1: 导入pandas库
```python
import pandas as pd
```
**解释**: 导入pandas库，用于数据处理和分析。

---

### Cell 2: 读取数据
```python
data = pd.read_csv("data.csv")
```
**解释**: 从CSV文件读取数据到pandas DataFrame对象`data`。该文件包含药物不良反应相关的数据。

---

### Cell 3: 提取分子特征
```python
molecular_df = data.loc[:, "molecular_weight":"covalent_unit_count"]
```
**解释**: 提取从"molecular_weight"到"covalent_unit_count"的所有列，这些是分子的物理化学特征（如分子量、氢键供体数、拓扑极性表面积等）。

---

### Cell 4: 基于聚类的数据分割
```python
from sklearn.cluster import KMeans

kmeans = KMeans(n_clusters=25, random_state=42).fit(molecular_df)
cluster_labels = pd.Series(kmeans.labels_)
tmp = cluster_labels.value_counts()
tmp = tmp / tmp.sum()
tmp = tmp.sample(frac=1, random_state=30).cumsum()
train_clusters = set(tmp[lambda x: x<.80].index)
test_clusters = set(tmp[lambda x: x>=.80].index)
train_mol = molecular_df.iloc[cluster_labels[lambda s: s.map(lambda x: x in train_clusters)].index]
test_mol = molecular_df.iloc[cluster_labels[lambda s: s.map(lambda x: x in test_clusters)].index]

train_test_split = pd.concat([
    train_mol[[]].reset_index().assign(type="train"),
    test_mol[[]].reset_index().assign(type="test"),
])
```
**详细解释**:
- **执行聚类**: 使用25个聚类对分子特征进行K-means聚类，`random_state=42`保证可重复性
- **获取标签**: 将聚类标签转换为pandas Series
- **计算比例**: 
  - `value_counts()`: 统计每个聚类的样本数
  - `tmp / tmp.sum()`: 计算每个聚类的占比
- **随机化并累积**: 
  - `sample(frac=1, random_state=30)`: 随机打乱聚类顺序
  - `cumsum()`: 计算累积和
- **分割聚类**: 
  - `train_clusters`: 累积占比<80%的聚类作为训练集
  - `test_clusters`: 累积占比≥80%的聚类作为测试集
- **提取数据**: 根据聚类标签提取对应的分子特征数据
- **创建分割记录**: 创建包含训练/测试标记的DataFrame

**目的**: 基于分子相似性进行数据分割，确保训练集和测试集在分子特征空间中有不同的分布，更符合实际应用场景。

---

### Cell 5: 标记训练/测试集
```python
data['type'] = 'Neither'

# Check if the values in DataFrame A exist in DataFrame B
mask_B = data.loc[:, "molecular_weight": "covalent_unit_count"].isin(train_mol).all(axis=1)
data.loc[mask_B, 'type'] = 'train'

mask_C = data.loc[:, "molecular_weight": "covalent_unit_count"].isin(test_mol).all(axis=1)
data.loc[mask_C, 'type'] = 'test'
```
**解释**: 
- **初始化**: 为所有样本创建'type'列，初始值为'Neither'
- **创建掩码**: 
  - `mask_B`: 检查每行的分子特征是否完全匹配训练集的分子特征（`all(axis=1)`确保所有列都匹配）
  - `mask_C`: 检查每行的分子特征是否完全匹配测试集的分子特征
- **标记数据**: 根据掩码将对应的行标记为'train'或'test'

---

### Cell 6: 检查类型分布
```python
data["type"].unique()
```
**解释**: 返回'type'列的所有唯一值，用于验证数据分割是否正确（应该包含'train'和'test'）。

---

### Cell 7: 特征标准化
```python
from sklearn.preprocessing import Normalizer

scaler = Normalizer()

# Fit and transform the data
data.loc[:, "molecular_weight":"covalent_unit_count"] = scaler.fit_transform(data.loc[:, "molecular_weight":"covalent_unit_count"])
```
**解释**: 
- **导入Normalizer**: 使用Normalizer进行特征标准化（将每行归一化为单位向量）
- **创建标准化器**: 实例化Normalizer对象
- **标准化**: 对分子特征列进行标准化，使每个样本的分子特征向量长度为1
- **注意**: Normalizer按行归一化，与StandardScaler（按列归一化）不同

---

### Cell 8: 删除冗余特征
```python
data.drop(["sex_F","age_group_1"], axis = 1,  inplace = True)
```
**解释**: 
- **删除列**: 删除"sex_F"和"age_group_1"列
- **axis=1**: 指定删除列（axis=0为行）
- **inplace=True**: 直接修改原DataFrame，不返回新对象
- **原因**: 这些是冗余特征（如sex_F和sex_M是互斥的，age_group_1可能是基准组）

---

### Cell 9: 提取训练集
```python
train = data[data["type"] == "train"]
```
**解释**: 使用布尔索引筛选出所有标记为"train"的行，创建训练集DataFrame。

---

### Cell 10: 提取测试集
```python
test = data[data["type"] == "test"]
```
**解释**: 使用布尔索引筛选出所有标记为"test"的行，创建测试集DataFrame。

---

### Cell 11: 计算测试集比例
```python
test.shape[0]/data.shape[0]
```
**解释**: 计算测试集样本数占总样本数的比例，用于验证数据分割比例是否合理（通常为20-30%）。

---

### Cell 12: 导入深度学习库
```python
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import roc_auc_score, average_precision_score
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.metrics import AUC
from tensorflow.keras import regularizers
from tensorflow.keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import train_test_split, GridSearchCV
import random
import tensorflow as tf
```
**解释**: 导入所需的库和函数：
- `numpy`: 数值计算
- `pandas`: 数据处理（已在Cell 1导入）
- `sklearn.metrics`: 评估指标（AUC、MAP）
- `tensorflow.keras`: 深度学习框架
  - `Sequential`: 顺序模型
  - `Dense`: 全连接层
  - `Dropout`: Dropout正则化层
  - `Adam`: Adam优化器
  - `AUC`: AUC评估指标
- `KerasClassifier`: 将Keras模型包装为sklearn兼容的估计器，用于网格搜索
- `GridSearchCV`: 网格搜索交叉验证
- **注意**: 有重复导入，但不影响功能

---

### Cell 13: 注释标记
```python
# ALL
```
**解释**: 注释标记，表示接下来将使用所有特征进行建模。

---

### Cell 14: 注释标记
```python
## Grid Search
```
**解释**: 注释标记，表示接下来将进行网格搜索超参数优化。

---

### Cell 15: 使用所有特征进行网格搜索
```python
x_train = train.loc[:, 'sex_M':"880"]
y_train = train.loc[:, 'cardiac failure': "vomiting"]
x_test = test.loc[:, 'sex_M':"880"]
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
def create_model(optimizer='adam', dropout_rate=0.5, activation='relu'):
    model = Sequential()
    model.add(Dense(512, activation=activation, input_shape=(x_train.shape[1],)))
    model.add(Dropout(dropout_rate))
    model.add(Dense(256, activation=activation))
    model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=[AUC(name='auc', multi_label=True)])
    return model

# Wrap the model using KerasClassifier
model = KerasClassifier(build_fn=create_model, epochs=10, batch_size=64, verbose=0)

# Define the parameter grid
param_grid = {
    'optimizer': ['adam', 'rmsprop'],
    'dropout_rate': [0.3, 0.5, 0.7],
    'activation': ['relu', 'tanh'],
    'batch_size': [32, 64, 128],
    'epochs': [10, 20, 100]
}

# GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, scoring='roc_auc', cv=3)
grid_result = grid.fit(x_train, y_train)

# Print the best parameters and best score
print(f"Best parameters found: {grid_result.best_params_}")
print(f"Best AUC score: {grid_result.best_score_}")

# Evaluate the best model on the test set
best_model = grid_result.best_estimator_.model
predictions = best_model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate the average AUC across all classes
average_auc = np.mean(auc_per_class)
print(f'Average AUC: {average_auc}')
```
**详细解释**:
- **特征提取**: 
  - `x_train/x_test`: 从'sex_M'到'880'的所有特征列（包括人口统计学、分子特征、化学特征、生物特征）
  - `y_train/y_test`: 从'cardiac failure'到'vomiting'的所有不良反应标签（30个标签，多标签分类）
- **模型定义函数**: 
  - `create_model()`: 创建神经网络模型的函数，接受超参数
  - **网络架构**:
    - 第一层: `Dense(512)`: 512个神经元，可配置激活函数
    - `Dropout`: Dropout层，可配置失活率（防止过拟合）
    - 第二层: `Dense(256)`: 256个神经元
    - 输出层: `Dense(30, activation='sigmoid')`: 30个神经元对应30个不良反应标签，sigmoid激活（多标签分类）
  - `compile()`: 编译模型
    - `loss='binary_crossentropy'`: 二元交叉熵损失（多标签分类）
    - `optimizer`: 可配置优化器
    - `metrics=[AUC(name='auc', multi_label=True)]`: 使用AUC作为评估指标，支持多标签
- **KerasClassifier包装**: 
  - `KerasClassifier`: 将Keras模型包装为sklearn兼容的估计器
  - `build_fn=create_model`: 指定模型创建函数
  - `epochs=10, batch_size=64`: 默认训练参数
  - `verbose=0`: 不显示训练过程
- **参数网格**: 
  - `optimizer`: ['adam', 'rmsprop'] - 优化器选择
  - `dropout_rate`: [0.3, 0.5, 0.7] - Dropout率
  - `activation`: ['relu', 'tanh'] - 激活函数
  - `batch_size`: [32, 64, 128] - 批次大小
  - `epochs`: [10, 20, 100] - 训练轮数
- **网格搜索**: 
  - `GridSearchCV`: 网格搜索交叉验证
  - `scoring='roc_auc'`: 使用AUC作为评分标准
  - `cv=3`: 3折交叉验证
  - `fit()`: 执行网格搜索
- **结果评估**: 
  - `best_params_`: 最佳超参数
  - `best_score_`: 最佳交叉验证分数
  - `best_estimator_.model`: 获取最佳模型
  - `predict()`: 对测试集进行预测
  - `roc_auc_score(..., average=None)`: 计算每个类别的AUC
  - `np.mean()`: 计算平均AUC

---

### Cell 16: 使用所有特征训练模型（固定超参数）
```python
x_train = train.loc[:, 'sex_M':"880"]
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = test.loc[:, 'sex_M':"880"]
y_test = test.loc[:, 'cardiac failure': "vomiting"]
model = Sequential()
model.add(Dense(512, activation='relu', input_shape=(x_train.shape[1],)))
model.add(Dropout(0.7))
model.add(Dense(256, activation='relu'))
model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification

# Compile the model with AUC as the metric
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=[AUC()])
model.fit(x_train, y_train, epochs=10, batch_size=32, validation_split=0.2)
```
**解释**: 
- **特征提取**: 与Cell 15相同
- **模型构建**: 
  - 使用固定超参数：ReLU激活、Dropout 0.7、Adam优化器
  - 网络结构：512 → Dropout(0.7) → 256 → 30
- **编译**: 使用二元交叉熵损失和AUC指标
- **训练**: 
  - `epochs=10`: 训练10轮
  - `batch_size=32`: 每批32个样本
  - `validation_split=0.2`: 20%训练数据用作验证集

---

### Cell 17: 评估模型性能
```python
from sklearn.metrics import roc_auc_score

predictions = model.predict(x_test)

auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate macro average AUC
macro_auc = roc_auc_score(y_test, predictions, average='macro')
print(f"Macro AUC: {macro_auc}")

map_per_class = average_precision_score(y_test, predictions, average=None)
print(f"MAP per class: {map_per_class}")

# Calculate macro average MAP
macro_map = average_precision_score(y_test, predictions, average='macro')
print(f"Macro MAP: {macro_map}")
```
**解释**: 
- **预测**: 对测试集进行预测，得到每个样本对30个不良反应标签的预测概率
- **AUC计算**: 
  - `average=None`: 计算每个类别的AUC
  - `average='macro'`: 计算宏平均AUC（所有类别AUC的平均值）
- **MAP计算**: 
  - `average_precision_score`: 计算平均精度（Mean Average Precision）
  - `average=None`: 每个类别的MAP
  - `average='macro'`: 宏平均MAP

---

### Cell 18: 检查变量
```python
probabilities
```
**解释**: 尝试访问`probabilities`变量（可能未定义），用于调试或检查预测概率。

---

### Cell 19: 注释标记
```python
# DEM
```
**解释**: 注释标记"DEM"（Demographic的缩写），表示接下来使用人口统计学特征。

---

### Cell 20: 仅使用人口统计学特征（网格搜索）
```python
x_train= train.loc[:, 'sex_M': 'age_group_5']
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = test.loc[:, 'sex_M': 'age_group_5']
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
def create_model(optimizer='adam', dropout_rate=0.5, activation='relu'):
    model = Sequential()
    model.add(Dense(512, activation=activation, input_shape=(x_train.shape[1],)))
    model.add(Dropout(dropout_rate))
    model.add(Dense(256, activation=activation))
    model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=[AUC(name='auc', multi_label=True)])
    return model

# Wrap the model using KerasClassifier
model = KerasClassifier(build_fn=create_model, epochs=10, batch_size=64, verbose=0)

# Define the parameter grid
param_grid = {
    'optimizer': ['adam', 'rmsprop'],
    'dropout_rate': [0.3, 0.5, 0.7],
    'activation': ['relu', 'tanh'],
    'batch_size': [32, 64, 128],
    'epochs': [10, 20, 100]
}

# GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, scoring='roc_auc', cv=3)
grid_result = grid.fit(x_train, y_train)

# Print the best parameters and best score
print(f"Best parameters found: {grid_result.best_params_}")
print(f"Best AUC score: {grid_result.best_score_}")

# Evaluate the best model on the test set
best_model = grid_result.best_estimator_.model
predictions = best_model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate the average AUC across all classes
average_auc = np.mean(auc_per_class)
print(f'Average AUC: {average_auc}')
```
**解释**: 
- **特征**: 仅使用人口统计学特征（性别和年龄组）
- **目的**: 评估人口统计学特征单独对不良反应预测的贡献
- **方法**: 与Cell 15相同的网格搜索流程

---

### Cell 21: 仅使用人口统计学特征（固定超参数）
```python
x_train= train.loc[:, 'sex_M': 'age_group_5']
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = test.loc[:, 'sex_M': 'age_group_5']
y_test = test.loc[:, 'cardiac failure': "vomiting"]
model = Sequential()
model.add(Dense(512, activation='tanh', input_shape=(x_train.shape[1],)))
model.add(Dropout(0.7))
model.add(Dense(256, activation='tanh'))
model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification

# Compile the model with AUC as the metric
model.compile(loss='binary_crossentropy', optimizer='rmsprop', metrics=[AUC()])
model.fit(x_train, y_train, epochs=100, batch_size=128, validation_split=0.2)
```
**解释**: 
- **特征**: 仅使用人口统计学特征
- **模型配置**: 
  - 使用tanh激活函数（而非ReLU）
  - RMSprop优化器（而非Adam）
  - Dropout 0.7
  - 训练100轮，批次大小128
- **目的**: 测试不同超参数组合对模型性能的影响

---

### Cell 22: 评估人口统计学特征模型
```python
predictions = model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate macro average AUC
macro_auc = roc_auc_score(y_test, predictions, average='macro')
print(f"Macro AUC: {macro_auc}")

map_per_class = average_precision_score(y_test, predictions, average=None)
print(f"MAP per class: {map_per_class}")

# Calculate macro average MAP
macro_map = average_precision_score(y_test, predictions, average='macro')
print(f"Macro MAP: {macro_map}")
```
**解释**: 与Cell 17相同的评估流程，计算AUC和MAP指标。

---

### Cell 23: 注释标记
```python
# Molecular
```
**解释**: 注释标记，表示接下来使用分子特征。

---

### Cell 24: 仅使用分子特征（网格搜索）
```python
x_train= train.loc[:, 'molecular_weight': 'covalent_unit_count']
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = test.loc[:, 'molecular_weight': 'covalent_unit_count']
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
def create_model(optimizer='adam', dropout_rate=0.5, activation='relu'):
    model = Sequential()
    model.add(Dense(512, activation=activation, input_shape=(x_train.shape[1],)))
    model.add(Dropout(dropout_rate))
    model.add(Dense(256, activation=activation))
    model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=[AUC(name='auc', multi_label=True)])
    return model

# Wrap the model using KerasClassifier
model = KerasClassifier(build_fn=create_model, epochs=10, batch_size=64, verbose=0)

# Define the parameter grid
param_grid = {
    'optimizer': ['adam', 'rmsprop'],
    'dropout_rate': [0.3, 0.5, 0.7],
    'activation': ['relu', 'tanh'],
    'batch_size': [32, 64, 128],
    'epochs': [10, 20, 100]
}

# GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, scoring='roc_auc', cv=3)
grid_result = grid.fit(x_train, y_train)

# Print the best parameters and best score
print(f"Best parameters found: {grid_result.best_params_}")
print(f"Best AUC score: {grid_result.best_score_}")

# Evaluate the best model on the test set
best_model = grid_result.best_estimator_.model
predictions = best_model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate the average AUC across all classes
average_auc = np.mean(auc_per_class)
print(f'Average AUC: {average_auc}')
```
**解释**: 
- **特征**: 仅使用分子物理化学特征（分子量、氢键数、拓扑极性表面积等）
- **目的**: 评估分子特征对不良反应预测的贡献
- **方法**: 与Cell 15相同的网格搜索流程

---

### Cell 25: 仅使用分子特征（固定超参数）
```python
x_train= train.loc[:, 'molecular_weight': 'covalent_unit_count']
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = test.loc[:, 'molecular_weight': 'covalent_unit_count']
y_test = test.loc[:, 'cardiac failure': "vomiting"]
model = Sequential()
model.add(Dense(512, activation='relu', input_shape=(x_train.shape[1],)))
model.add(Dropout(0.3))
model.add(Dense(256, activation='relu'))
model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification

# Compile the model with AUC as the metric
model.compile(loss='binary_crossentropy', optimizer='rmsprop', metrics=[AUC()])
model.fit(x_train, y_train, epochs=100, batch_size=32, validation_split=0.2)
```
**解释**: 
- **特征**: 仅使用分子特征
- **模型配置**: 
  - Dropout 0.3（较低，因为特征较少）
  - RMSprop优化器
  - 训练100轮，批次大小32

---

### Cell 26: 评估分子特征模型
```python
predictions = model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate macro average AUC
macro_auc = roc_auc_score(y_test, predictions, average='macro')
print(f"Macro AUC: {macro_auc}")

map_per_class = average_precision_score(y_test, predictions, average=None)
print(f"MAP per class: {map_per_class}")

# Calculate macro average MAP
macro_map = average_precision_score(y_test, predictions, average='macro')
print(f"Macro MAP: {macro_map}")
```
**解释**: 评估仅使用分子特征的模型性能。

---

### Cell 27: 注释标记
```python
# Chemical
```
**解释**: 注释标记，表示接下来使用化学特征。

---

### Cell 28: 仅使用化学特征（网格搜索）
```python
x_train= train.loc[:, "1":"880"]
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = test.loc[:, "1":"880"]
y_test = test.loc[:, 'cardiac failure': "vomiting"]
# Define the model
def create_model(optimizer='adam', dropout_rate=0.5, activation='relu'):
    model = Sequential()
    model.add(Dense(512, activation=activation, input_shape=(x_train.shape[1],)))
    model.add(Dropout(dropout_rate))
    model.add(Dense(256, activation=activation))
    model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=[AUC(name='auc', multi_label=True)])
    return model

# Wrap the model using KerasClassifier
model = KerasClassifier(build_fn=create_model, epochs=10, batch_size=64, verbose=0)

# Define the parameter grid
param_grid = {
    'optimizer': ['adam', 'rmsprop'],
    'dropout_rate': [0.3, 0.5, 0.7],
    'activation': ['relu', 'tanh'],
    'batch_size': [32, 64, 128],
    'epochs': [10, 20, 100]
}

# GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, scoring='roc_auc', cv=3)
grid_result = grid.fit(x_train, y_train)

# Print the best parameters and best score
print(f"Best parameters found: {grid_result.best_params_}")
print(f"Best AUC score: {grid_result.best_score_}")

# Evaluate the best model on the test set
best_model = grid_result.best_estimator_.model
predictions = best_model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate the average AUC across all classes
average_auc = np.mean(auc_per_class)
print(f'Average AUC: {average_auc}')
```
**解释**: 
- **特征**: 仅使用化学特征（列名"1"到"880"，可能是分子指纹或化学描述符）
- **目的**: 评估化学特征对不良反应预测的贡献
- **方法**: 与Cell 15相同的网格搜索流程

---

### Cell 29: 仅使用化学特征（固定超参数）
```python
x_train= train.loc[:, "1":"880"]
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = test.loc[:, "1":"880"]
y_test = test.loc[:, 'cardiac failure': "vomiting"]
model = Sequential()
model.add(Dense(512, activation='relu', input_shape=(x_train.shape[1],)))
model.add(Dropout(0.7))
model.add(Dense(256, activation='relu'))
model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification

# Compile the model with AUC as the metric
model.compile(loss='binary_crossentropy', optimizer='rmsprop', metrics=[AUC()])
model.fit(x_train, y_train, epochs=100, batch_size=128, validation_split=0.2)
```
**解释**: 
- **特征**: 仅使用化学特征
- **模型配置**: 
  - Dropout 0.7（较高，因为特征维度大）
  - RMSprop优化器
  - 训练100轮，批次大小128

---

### Cell 30: 评估化学特征模型
```python
predictions = model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate macro average AUC
macro_auc = roc_auc_score(y_test, predictions, average='macro')
print(f"Macro AUC: {macro_auc}")

map_per_class = average_precision_score(y_test, predictions, average=None)
print(f"MAP per class: {map_per_class}")

# Calculate macro average MAP
macro_map = average_precision_score(y_test, predictions, average='macro')
print(f"Macro MAP: {macro_map}")
```
**解释**: 评估仅使用化学特征的模型性能。

---

### Cell 31: 注释标记
```python
# Bio
```
**解释**: 注释标记，表示接下来使用生物特征（蛋白质特征）。

---

### Cell 32: 仅使用生物特征（网格搜索）
```python
x_train= train.loc[:, "A0A068JFB7":"W7JWW5"]
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = test.loc[:, "A0A068JFB7":"W7JWW5"]
y_test = test.loc[:, 'cardiac failure': "vomiting"]
# Define the model
def create_model(optimizer='adam', dropout_rate=0.5, activation='relu'):
    model = Sequential()
    model.add(Dense(512, activation=activation, input_shape=(x_train.shape[1],)))
    model.add(Dropout(dropout_rate))
    model.add(Dense(256, activation=activation))
    model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=[AUC(name='auc', multi_label=True)])
    return model

# Wrap the model using KerasClassifier
model = KerasClassifier(build_fn=create_model, epochs=10, batch_size=64, verbose=0)

# Define the parameter grid
param_grid = {
    'optimizer': ['adam', 'rmsprop'],
    'dropout_rate': [0.3, 0.5, 0.7],
    'activation': ['relu', 'tanh'],
    'batch_size': [32, 64, 128],
    'epochs': [10, 20, 100]
}

# GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, scoring='roc_auc', cv=3)
grid_result = grid.fit(x_train, y_train)

# Print the best parameters and best score
print(f"Best parameters found: {grid_result.best_params_}")
print(f"Best AUC score: {grid_result.best_score_}")

# Evaluate the best model on the test set
best_model = grid_result.best_estimator_.model
predictions = best_model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate the average AUC across all classes
average_auc = np.mean(auc_per_class)
print(f'Average AUC: {average_auc}')
```
**解释**: 
- **特征**: 仅使用蛋白质相互作用特征（UniProt格式的蛋白质ID）
- **目的**: 评估生物特征对不良反应预测的贡献
- **方法**: 与Cell 15相同的网格搜索流程

---

### Cell 33: 仅使用生物特征（固定超参数）
```python
x_train= train.loc[:, "A0A068JFB7":"W7JWW5"]
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = test.loc[:, "A0A068JFB7":"W7JWW5"]
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
model = Sequential()
model.add(Dense(512, activation='relu', input_shape=(x_train.shape[1],)))
model.add(Dropout(0.7))
model.add(Dense(256, activation='relu'))
model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification

# Compile the model with AUC as the metric
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=[AUC()])
model.fit(x_train, y_train, epochs=10, batch_size=32, validation_split=0.2)
```
**解释**: 
- **特征**: 仅使用生物特征
- **模型配置**: 
  - Dropout 0.7
  - Adam优化器
  - 训练10轮，批次大小32

---

### Cell 34: 评估生物特征模型
```python
predictions = model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate macro average AUC
macro_auc = roc_auc_score(y_test, predictions, average='macro')
print(f"Macro AUC: {macro_auc}")

map_per_class = average_precision_score(y_test, predictions, average=None)
print(f"MAP per class: {map_per_class}")

# Calculate macro average MAP
macro_map = average_precision_score(y_test, predictions, average='macro')
print(f"Macro MAP: {macro_map}")
```
**解释**: 评估仅使用生物特征的模型性能。

---

### Cell 35: 注释标记
```python
# BIO+DEMO
```
**解释**: 注释标记，表示使用生物特征+人口统计学特征。

---

### Cell 36: 生物特征+人口统计学特征（网格搜索）
```python
x_train = pd.concat([train.loc[:, "A0A068JFB7":"W7JWW5"], train.loc[:, "sex_M":"age_group_5"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([test.loc[:, "A0A068JFB7":"W7JWW5"], test.loc[:, "sex_M":"age_group_5"]], axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
def create_model(optimizer='adam', dropout_rate=0.5, activation='relu'):
    model = Sequential()
    model.add(Dense(512, activation=activation, input_shape=(x_train.shape[1],)))
    model.add(Dropout(dropout_rate))
    model.add(Dense(256, activation=activation))
    model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=[AUC(name='auc', multi_label=True)])
    return model

# Wrap the model using KerasClassifier
model = KerasClassifier(build_fn=create_model, epochs=10, batch_size=64, verbose=0)

# Define the parameter grid
param_grid = {
    'optimizer': ['adam', 'rmsprop'],
    'dropout_rate': [0.3, 0.5, 0.7],
    'activation': ['relu', 'tanh'],
    'batch_size': [32, 64, 128],
    'epochs': [10, 20, 100]
}

# GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, scoring='roc_auc', cv=3)
grid_result = grid.fit(x_train, y_train)

# Print the best parameters and best score
print(f"Best parameters found: {grid_result.best_params_}")
print(f"Best AUC score: {grid_result.best_score_}")

# Evaluate the best model on the test set
best_model = grid_result.best_estimator_.model
predictions = best_model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate the average AUC across all classes
average_auc = np.mean(auc_per_class)
print(f'Average AUC: {average_auc}')
```
**解释**: 
- **特征组合**: 使用`pd.concat()`水平拼接生物特征和人口统计学特征
- **axis=1**: 按列拼接
- **目的**: 评估组合特征的预测能力
- **方法**: 与Cell 15相同的网格搜索流程

---

### Cell 37: 生物特征+人口统计学特征（固定超参数）
```python
x_train = pd.concat([train.loc[:, "A0A068JFB7":"W7JWW5"], train.loc[:, "sex_M":"age_group_5"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([test.loc[:, "A0A068JFB7":"W7JWW5"], test.loc[:, "sex_M":"age_group_5"]], axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
model = Sequential()
model.add(Dense(512, activation='relu', input_shape=(x_train.shape[1],)))
model.add(Dropout(0.7))
model.add(Dense(256, activation='relu'))
model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification

# Compile the model with AUC as the metric
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=[AUC()])
model.fit(x_train, y_train, epochs=100, batch_size=64, validation_split=0.2)
```
**解释**: 
- **特征组合**: 生物特征+人口统计学特征
- **模型配置**: 
  - Dropout 0.7
  - Adam优化器
  - 训练100轮，批次大小64

---

### Cell 38: 评估生物+人口统计学特征模型
```python
predictions = model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate macro average AUC
macro_auc = roc_auc_score(y_test, predictions, average='macro')
print(f"Macro AUC: {macro_auc}")

map_per_class = average_precision_score(y_test, predictions, average=None)
print(f"MAP per class: {map_per_class}")

# Calculate macro average MAP
macro_map = average_precision_score(y_test, predictions, average='macro')
print(f"Macro MAP: {macro_map}")
```
**解释**: 评估生物+人口统计学特征组合的模型性能。

---

### Cell 39: 空单元格
```python

```
**解释**: 空单元格，可能用于临时测试或注释。

---

### Cell 40: 注释标记
```python
# Chemical + demo
```
**解释**: 注释标记，表示使用化学特征+人口统计学特征。

---

### Cell 41: 化学特征+人口统计学特征（网格搜索）
```python
x_train = pd.concat([train.loc[:, "1":"880"], train.loc[:, "sex_M":"age_group_5"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([test.loc[:, "1":"880"], test.loc[:, "sex_M":"age_group_5"]], axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
def create_model(optimizer='adam', dropout_rate=0.5, activation='relu'):
    model = Sequential()
    model.add(Dense(512, activation=activation, input_shape=(x_train.shape[1],)))
    model.add(Dropout(dropout_rate))
    model.add(Dense(256, activation=activation))
    model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=[AUC(name='auc', multi_label=True)])
    return model

# Wrap the model using KerasClassifier
model = KerasClassifier(build_fn=create_model, epochs=10, batch_size=64, verbose=0)

# Define the parameter grid
param_grid = {
    'optimizer': ['adam', 'rmsprop'],
    'dropout_rate': [0.3, 0.5, 0.7],
    'activation': ['relu', 'tanh'],
    'batch_size': [32, 64, 128],
    'epochs': [10, 20, 100]
}

# GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, scoring='roc_auc', cv=3)
grid_result = grid.fit(x_train, y_train)

# Print the best parameters and best score
print(f"Best parameters found: {grid_result.best_params_}")
print(f"Best AUC score: {grid_result.best_score_}")

# Evaluate the best model on the test set
best_model = grid_result.best_estimator_.model
predictions = best_model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate the average AUC across all classes
average_auc = np.mean(auc_per_class)
print(f'Average AUC: {average_auc}')
```
**解释**: 组合化学特征和人口统计学特征，使用网格搜索优化超参数。

---

### Cell 42: 化学特征+人口统计学特征（固定超参数）
```python
x_train = pd.concat([train.loc[:, "1":"880"], train.loc[:, "sex_M":"age_group_5"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([test.loc[:, "1":"880"], test.loc[:, "sex_M":"age_group_5"]], axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]


# Define the model
model = Sequential()
model.add(Dense(512, activation='relu', input_shape=(x_train.shape[1],)))
model.add(Dropout(0.7))
model.add(Dense(256, activation='relu'))
model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification

# Compile the model with AUC as the metric
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=[AUC()])
model.fit(x_train, y_train, epochs=100, batch_size=128, validation_split=0.2)
```
**解释**: 使用固定超参数训练化学+人口统计学特征组合模型。

---

### Cell 43: 评估化学+人口统计学特征模型
```python
predictions = model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate macro average AUC
macro_auc = roc_auc_score(y_test, predictions, average='macro')
print(f"Macro AUC: {macro_auc}")

map_per_class = average_precision_score(y_test, predictions, average=None)
print(f"MAP per class: {map_per_class}")

# Calculate macro average MAP
macro_map = average_precision_score(y_test, predictions, average='macro')
print(f"Macro MAP: {macro_map}")
```
**解释**: 评估化学+人口统计学特征组合的模型性能。

---

### Cell 44: 注释标记
```python
# Molecular +Demo
```
**解释**: 注释标记，表示使用分子特征+人口统计学特征。

---

### Cell 45: 分子特征+人口统计学特征（网格搜索）
```python
x_train = pd.concat([train.loc[:, 'molecular_weight': 'covalent_unit_count'], train.loc[:, "sex_M":"age_group_5"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([test.loc[:, 'molecular_weight': 'covalent_unit_count'], test.loc[:, "sex_M":"age_group_5"]], axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
def create_model(optimizer='adam', dropout_rate=0.5, activation='relu'):
    model = Sequential()
    model.add(Dense(512, activation=activation, input_shape=(x_train.shape[1],)))
    model.add(Dropout(dropout_rate))
    model.add(Dense(256, activation=activation))
    model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=[AUC(name='auc', multi_label=True)])
    return model

# Wrap the model using KerasClassifier
model = KerasClassifier(build_fn=create_model, epochs=10, batch_size=64, verbose=0)

# Define the parameter grid
param_grid = {
    'optimizer': ['adam', 'rmsprop'],
    'dropout_rate': [0.3, 0.5, 0.7],
    'activation': ['relu', 'tanh'],
    'batch_size': [32, 64, 128],
    'epochs': [10, 20, 100]
}

# GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, scoring='roc_auc', cv=3)
grid_result = grid.fit(x_train, y_train)

# Print the best parameters and best score
print(f"Best parameters found: {grid_result.best_params_}")
print(f"Best AUC score: {grid_result.best_score_}")

# Evaluate the best model on the test set
best_model = grid_result.best_estimator_.model
predictions = best_model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate the average AUC across all classes
average_auc = np.mean(auc_per_class)
print(f'Average AUC: {average_auc}')
```
**解释**: 组合分子特征和人口统计学特征，使用网格搜索优化超参数。

---

### Cell 46: 分子特征+人口统计学特征（固定超参数）
```python
x_train = pd.concat([train.loc[:, 'molecular_weight': 'covalent_unit_count'], train.loc[:, "sex_M":"age_group_5"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([test.loc[:, 'molecular_weight': 'covalent_unit_count'], test.loc[:, "sex_M":"age_group_5"]], axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]


# Define the model
model = Sequential()
model.add(Dense(512, activation='relu', input_shape=(x_train.shape[1],)))
model.add(Dropout(0.7))
model.add(Dense(256, activation='relu'))
model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification

# Compile the model with AUC as the metric
model.compile(loss='binary_crossentropy', optimizer='rmsprop', metrics=[AUC()])
model.fit(x_train, y_train, epochs=100, batch_size=32, validation_split=0.2)
```
**解释**: 
- **特征组合**: 分子特征+人口统计学特征
- **模型配置**: 
  - Dropout 0.7
  - RMSprop优化器
  - 训练100轮，批次大小32

---

### Cell 47: 评估分子+人口统计学特征模型
```python
predictions = model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate macro average AUC
macro_auc = roc_auc_score(y_test, predictions, average='macro')
print(f"Macro AUC: {macro_auc}")

map_per_class = average_precision_score(y_test, predictions, average=None)
print(f"MAP per class: {map_per_class}")

# Calculate macro average MAP
macro_map = average_precision_score(y_test, predictions, average='macro')
print(f"Macro MAP: {macro_map}")
```
**解释**: 评估分子+人口统计学特征组合的模型性能。

---

### Cell 48: 注释标记
```python
# Molecular +bio
```
**解释**: 注释标记，表示使用分子特征+生物特征。

---

### Cell 49: 分子特征+生物特征（网格搜索）
```python
x_train = pd.concat([train.loc[:, 'molecular_weight': 'covalent_unit_count'], train.loc[:, "A0A068JFB7":"W7JWW5"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([test.loc[:, 'molecular_weight': 'covalent_unit_count'], test.loc[:, "A0A068JFB7":"W7JWW5"]], axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
def create_model(optimizer='adam', dropout_rate=0.5, activation='relu'):
    model = Sequential()
    model.add(Dense(512, activation=activation, input_shape=(x_train.shape[1],)))
    model.add(Dropout(dropout_rate))
    model.add(Dense(256, activation=activation))
    model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=[AUC(name='auc', multi_label=True)])
    return model

# Wrap the model using KerasClassifier
model = KerasClassifier(build_fn=create_model, epochs=10, batch_size=64, verbose=0)

# Define the parameter grid
param_grid = {
    'optimizer': ['adam', 'rmsprop'],
    'dropout_rate': [0.3, 0.5, 0.7],
    'activation': ['relu', 'tanh'],
    'batch_size': [32, 64, 128],
    'epochs': [10, 20, 100]
}

# GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, scoring='roc_auc', cv=3)
grid_result = grid.fit(x_train, y_train)

# Print the best parameters and best score
print(f"Best parameters found: {grid_result.best_params_}")
print(f"Best AUC score: {grid_result.best_score_}")

# Evaluate the best model on the test set
best_model = grid_result.best_estimator_.model
predictions = best_model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate the average AUC across all classes
average_auc = np.mean(auc_per_class)
print(f'Average AUC: {average_auc}')
```
**解释**: 组合分子特征和生物特征，使用网格搜索优化超参数。

---

### Cell 50: 分子特征+生物特征（固定超参数）
```python
x_train = pd.concat([train.loc[:, 'molecular_weight': 'covalent_unit_count'], train.loc[:, "A0A068JFB7":"W7JWW5"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([test.loc[:, 'molecular_weight': 'covalent_unit_count'], test.loc[:, "A0A068JFB7":"W7JWW5"]], axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
model = Sequential()
model.add(Dense(512, activation='relu', input_shape=(x_train.shape[1],)))
model.add(Dropout(0.7))
model.add(Dense(256, activation='relu'))
model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification

# Compile the model with AUC as the metric
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=[AUC()])
model.fit(x_train, y_train, epochs=10, batch_size=128, validation_split=0.2)
```
**解释**: 
- **特征组合**: 分子特征+生物特征
- **模型配置**: 
  - Dropout 0.7
  - Adam优化器
  - 训练10轮，批次大小128

---

### Cell 51: 评估分子+生物特征模型
```python
predictions = model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate macro average AUC
macro_auc = roc_auc_score(y_test, predictions, average='macro')
print(f"Macro AUC: {macro_auc}")

map_per_class = average_precision_score(y_test, predictions, average=None)
print(f"MAP per class: {map_per_class}")

# Calculate macro average MAP
macro_map = average_precision_score(y_test, predictions, average='macro')
print(f"Macro MAP: {macro_map}")
```
**解释**: 评估分子+生物特征组合的模型性能。

---

### Cell 52: 注释标记
```python
# Chemical molecular
```
**解释**: 注释标记，表示使用化学特征+分子特征。

---

### Cell 53: 化学特征+分子特征（网格搜索）
```python
x_train = pd.concat([train.loc[:, 'molecular_weight': 'covalent_unit_count'], train.loc[:, "1":"880"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([test.loc[:, 'molecular_weight': 'covalent_unit_count'], test.loc[:, "1":"880"]], axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
def create_model(optimizer='adam', dropout_rate=0.5, activation='relu'):
    model = Sequential()
    model.add(Dense(512, activation=activation, input_shape=(x_train.shape[1],)))
    model.add(Dropout(dropout_rate))
    model.add(Dense(256, activation=activation))
    model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=[AUC(name='auc', multi_label=True)])
    return model

# Wrap the model using KerasClassifier
model = KerasClassifier(build_fn=create_model, epochs=10, batch_size=64, verbose=0)

# Define the parameter grid
param_grid = {
    'optimizer': ['adam', 'rmsprop'],
    'dropout_rate': [0.3, 0.5, 0.7],
    'activation': ['relu', 'tanh'],
    'batch_size': [32, 64, 128],
    'epochs': [10, 20, 100]
}

# GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, scoring='roc_auc', cv=3)
grid_result = grid.fit(x_train, y_train)

# Print the best parameters and best score
print(f"Best parameters found: {grid_result.best_params_}")
print(f"Best AUC score: {grid_result.best_score_}")

# Evaluate the best model on the test set
best_model = grid_result.best_estimator_.model
predictions = best_model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate the average AUC across all classes
average_auc = np.mean(auc_per_class)
print(f'Average AUC: {average_auc}')
```
**解释**: 组合化学特征和分子特征，使用网格搜索优化超参数。

---

### Cell 54: 化学特征+分子特征（固定超参数）
```python
x_train = pd.concat([train.loc[:, 'molecular_weight': 'covalent_unit_count'], train.loc[:, "1":"880"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([test.loc[:, 'molecular_weight': 'covalent_unit_count'], test.loc[:, "1":"880"]], axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
model = Sequential()
model.add(Dense(512, activation='relu', input_shape=(x_train.shape[1],)))
model.add(Dropout(0.5))
model.add(Dense(256, activation='relu'))
model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification

# Compile the model with AUC as the metric
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=[AUC()])
model.fit(x_train, y_train, epochs=100, batch_size=128, validation_split=0.2)
```
**解释**: 
- **特征组合**: 化学特征+分子特征
- **模型配置**: 
  - Dropout 0.5（中等）
  - Adam优化器
  - 训练100轮，批次大小128

---

### Cell 55: 评估化学+分子特征模型
```python
predictions = model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate macro average AUC
macro_auc = roc_auc_score(y_test, predictions, average='macro')
print(f"Macro AUC: {macro_auc}")

map_per_class = average_precision_score(y_test, predictions, average=None)
print(f"MAP per class: {map_per_class}")

# Calculate macro average MAP
macro_map = average_precision_score(y_test, predictions, average='macro')
print(f"Macro MAP: {macro_map}")
```
**解释**: 评估化学+分子特征组合的模型性能。

---

### Cell 56: 注释标记
```python
# Chemical Bio
```
**解释**: 注释标记，表示使用化学特征+生物特征。

---

### Cell 57: 化学特征+生物特征（网格搜索）
```python
x_train = pd.concat([train.loc[:, "A0A068JFB7":"W7JWW5"], train.loc[:, "1":"880"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([test.loc[:, "A0A068JFB7":"W7JWW5"], test.loc[:, "1":"880"]], axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
def create_model(optimizer='adam', dropout_rate=0.5, activation='relu'):
    model = Sequential()
    model.add(Dense(512, activation=activation, input_shape=(x_train.shape[1],)))
    model.add(Dropout(dropout_rate))
    model.add(Dense(256, activation=activation))
    model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=[AUC(name='auc', multi_label=True)])
    return model

# Wrap the model using KerasClassifier
model = KerasClassifier(build_fn=create_model, epochs=10, batch_size=64, verbose=0)

# Define the parameter grid
param_grid = {
    'optimizer': ['adam', 'rmsprop'],
    'dropout_rate': [0.3, 0.5, 0.7],
    'activation': ['relu', 'tanh'],
    'batch_size': [32, 64, 128],
    'epochs': [10, 20, 100]
}

# GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, scoring='roc_auc', cv=3)
grid_result = grid.fit(x_train, y_train)

# Print the best parameters and best score
print(f"Best parameters found: {grid_result.best_params_}")
print(f"Best AUC score: {grid_result.best_score_}")

# Evaluate the best model on the test set
best_model = grid_result.best_estimator_.model
predictions = best_model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate the average AUC across all classes
average_auc = np.mean(auc_per_class)
print(f'Average AUC: {average_auc}')
```
**解释**: 组合化学特征和生物特征，使用网格搜索优化超参数。

---

### Cell 58: 化学特征+生物特征（固定超参数）
```python
x_train = pd.concat([train.loc[:, "A0A068JFB7":"W7JWW5"], train.loc[:, "1":"880"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([test.loc[:, "A0A068JFB7":"W7JWW5"], test.loc[:, "1":"880"]], axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]
model = Sequential()
model.add(Dense(512, activation='relu', input_shape=(x_train.shape[1],)))
model.add(Dropout(0.7))
model.add(Dense(256, activation='relu'))
model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification

# Compile the model with AUC as the metric
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=[AUC()])
model.fit(x_train, y_train, epochs=20, batch_size=32, validation_split=0.2)
```
**解释**: 
- **特征组合**: 化学特征+生物特征
- **模型配置**: 
  - Dropout 0.7
  - Adam优化器
  - 训练20轮，批次大小32

---

### Cell 59: 评估化学+生物特征模型
```python
predictions = model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate macro average AUC
macro_auc = roc_auc_score(y_test, predictions, average='macro')
print(f"Macro AUC: {macro_auc}")

map_per_class = average_precision_score(y_test, predictions, average=None)
print(f"MAP per class: {map_per_class}")

# Calculate macro average MAP
macro_map = average_precision_score(y_test, predictions, average='macro')
print(f"Macro MAP: {macro_map}")
```
**解释**: 评估化学+生物特征组合的模型性能。

---

### Cell 60: 注释标记
```python
# Chemical + Molecular + Demographic
```
**解释**: 注释标记，表示使用化学+分子+人口统计学特征。

---

### Cell 61: 化学+分子+人口统计学特征（网格搜索）
```python
x_train = pd.concat([train.loc[:, "molecular_weight":"880"], train.loc[:, "sex_M":"age_group_5"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([test.loc[:, "molecular_weight":"880"], test.loc[:, "sex_M":"age_group_5"]],  axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
def create_model(optimizer='adam', dropout_rate=0.5, activation='relu'):
    model = Sequential()
    model.add(Dense(512, activation=activation, input_shape=(x_train.shape[1],)))
    model.add(Dropout(dropout_rate))
    model.add(Dense(256, activation=activation))
    model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=[AUC(name='auc', multi_label=True)])
    return model

# Wrap the model using KerasClassifier
model = KerasClassifier(build_fn=create_model, epochs=10, batch_size=64, verbose=0)

# Define the parameter grid
param_grid = {
    'optimizer': ['adam', 'rmsprop'],
    'dropout_rate': [0.3, 0.5, 0.7],
    'activation': ['relu', 'tanh'],
    'batch_size': [32, 64, 128],
    'epochs': [10, 20, 100]
}

# GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, scoring='roc_auc', cv=3)
grid_result = grid.fit(x_train, y_train)

# Print the best parameters and best score
print(f"Best parameters found: {grid_result.best_params_}")
print(f"Best AUC score: {grid_result.best_score_}")

# Evaluate the best model on the test set
best_model = grid_result.best_estimator_.model
predictions = best_model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate the average AUC across all classes
average_auc = np.mean(auc_per_class)
print(f'Average AUC: {average_auc}')
```
**解释**: 组合化学、分子和人口统计学特征，使用网格搜索优化超参数。

---

### Cell 62: 化学+分子+人口统计学特征（固定超参数）
```python
x_train = pd.concat([train.loc[:, "molecular_weight":"880"], train.loc[:, "sex_M":"age_group_5"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([test.loc[:, "molecular_weight":"880"], test.loc[:, "sex_M":"age_group_5"]],  axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]
model = Sequential()
model.add(Dense(512, activation='relu', input_shape=(x_train.shape[1],)))
model.add(Dropout(0.7))
model.add(Dense(256, activation='relu'))
model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification

# Compile the model with AUC as the metric
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=[AUC()])
model.fit(x_train, y_train, epochs=100, batch_size=64, validation_split=0.2)
```
**解释**: 
- **特征组合**: 化学+分子+人口统计学特征
- **模型配置**: 
  - Dropout 0.7
  - Adam优化器
  - 训练100轮，批次大小64

---

### Cell 63: 评估化学+分子+人口统计学特征模型
```python
predictions = model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate macro average AUC
macro_auc = roc_auc_score(y_test, predictions, average='macro')
print(f"Macro AUC: {macro_auc}")

map_per_class = average_precision_score(y_test, predictions, average=None)
print(f"MAP per class: {map_per_class}")

# Calculate macro average MAP
macro_map = average_precision_score(y_test, predictions, average='macro')
print(f"Macro MAP: {macro_map}")
```
**解释**: 评估化学+分子+人口统计学特征组合的模型性能。

---

### Cell 64: 注释标记
```python
# bio + Molecular + Demographic
```
**解释**: 注释标记，表示使用生物+分子+人口统计学特征。

---

### Cell 65: 生物+分子+人口统计学特征（网格搜索）
```python
x_train = train.loc[:, "sex_M":"covalent_unit_count"]
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = test.loc[:, "sex_M":"covalent_unit_count"]
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
def create_model(optimizer='adam', dropout_rate=0.5, activation='relu'):
    model = Sequential()
    model.add(Dense(512, activation=activation, input_shape=(x_train.shape[1],)))
    model.add(Dropout(dropout_rate))
    model.add(Dense(256, activation=activation))
    model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=[AUC(name='auc', multi_label=True)])
    return model

# Wrap the model using KerasClassifier
model = KerasClassifier(build_fn=create_model, epochs=10, batch_size=64, verbose=0)

# Define the parameter grid
param_grid = {
    'optimizer': ['adam', 'rmsprop'],
    'dropout_rate': [0.3, 0.5, 0.7],
    'activation': ['relu', 'tanh'],
    'batch_size': [32, 64, 128],
    'epochs': [10, 20, 100]
}

# GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, scoring='roc_auc', cv=3)
grid_result = grid.fit(x_train, y_train)

# Print the best parameters and best score
print(f"Best parameters found: {grid_result.best_params_}")
print(f"Best AUC score: {grid_result.best_score_}")

# Evaluate the best model on the test set
best_model = grid_result.best_estimator_.model
predictions = best_model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate the average AUC across all classes
average_auc = np.mean(auc_per_class)
print(f'Average AUC: {average_auc}')
```
**解释**: 使用从"sex_M"到"covalent_unit_count"的所有列（包含人口统计学、分子和生物特征），使用网格搜索优化超参数。

---

### Cell 66: 生物+分子+人口统计学特征（固定超参数）
```python
x_train = train.loc[:, "sex_M":"covalent_unit_count"]
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = test.loc[:, "sex_M":"covalent_unit_count"]
y_test = test.loc[:, 'cardiac failure': "vomiting"]
model = Sequential()
model.add(Dense(512, activation='relu', input_shape=(x_train.shape[1],)))
model.add(Dropout(0.9))
model.add(Dense(256, activation='relu'))
model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification

# Compile the model with AUC as the metric
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=[AUC()])
model.fit(x_train, y_train, epochs=10, batch_size=128, validation_split=0.2)
```
**解释**: 
- **特征组合**: 生物+分子+人口统计学特征
- **模型配置**: 
  - Dropout 0.9（非常高，可能是为了测试极端正则化）
  - Adam优化器
  - 训练10轮，批次大小128

---

### Cell 67: 评估生物+分子+人口统计学特征模型
```python
predictions = model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate macro average AUC
macro_auc = roc_auc_score(y_test, predictions, average='macro')
print(f"Macro AUC: {macro_auc}")

map_per_class = average_precision_score(y_test, predictions, average=None)
print(f"MAP per class: {map_per_class}")

# Calculate macro average MAP
macro_map = average_precision_score(y_test, predictions, average='macro')
print(f"Macro MAP: {macro_map}")
```
**解释**: 评估生物+分子+人口统计学特征组合的模型性能。

---

### Cell 68: 注释标记
```python
# bio chemical demo
```
**解释**: 注释标记，表示使用生物+化学+人口统计学特征。

---

### Cell 69: 生物+化学+人口统计学特征（网格搜索）
```python
x_train = pd.concat([ train.loc[:, "sex_M":"W7JWW5"], train.loc[:, "1":"880"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([ test.loc[:, "sex_M":"W7JWW5"], test.loc[:, "1":"880"]],  axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
def create_model(optimizer='adam', dropout_rate=0.5, activation='relu'):
    model = Sequential()
    model.add(Dense(512, activation=activation, input_shape=(x_train.shape[1],)))
    model.add(Dropout(dropout_rate))
    model.add(Dense(256, activation=activation))
    model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=[AUC(name='auc', multi_label=True)])
    return model

# Wrap the model using KerasClassifier
model = KerasClassifier(build_fn=create_model, epochs=10, batch_size=64, verbose=0)

# Define the parameter grid
param_grid = {
    'optimizer': ['adam', 'rmsprop'],
    'dropout_rate': [0.3, 0.5, 0.7],
    'activation': ['relu', 'tanh'],
    'batch_size': [32, 64, 128],
    'epochs': [10, 20, 100]
}

# GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, scoring='roc_auc', cv=3)
grid_result = grid.fit(x_train, y_train)

# Print the best parameters and best score
print(f"Best parameters found: {grid_result.best_params_}")
print(f"Best AUC score: {grid_result.best_score_}")

# Evaluate the best model on the test set
best_model = grid_result.best_estimator_.model
predictions = best_model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate the average AUC across all classes
average_auc = np.mean(auc_per_class)
print(f'Average AUC: {average_auc}')
```
**解释**: 组合生物、化学和人口统计学特征，使用网格搜索优化超参数。

---

### Cell 70: 生物+化学+人口统计学特征（固定超参数）
```python
x_train = pd.concat([ train.loc[:, "sex_M":"W7JWW5"], train.loc[:, "1":"880"]], axis=1)
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = pd.concat([ test.loc[:, "sex_M":"W7JWW5"], test.loc[:, "1":"880"]],  axis=1)
y_test = test.loc[:, 'cardiac failure': "vomiting"]

model = Sequential()
model.add(Dense(512, activation='relu', input_shape=(x_train.shape[1],)))
model.add(Dropout(0.7))
model.add(Dense(256, activation='relu'))
model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification

# Compile the model with AUC as the metric
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=[AUC()])
model.fit(x_train, y_train, epochs=20, batch_size=128, validation_split=0.2)
```
**解释**: 
- **特征组合**: 生物+化学+人口统计学特征
- **模型配置**: 
  - Dropout 0.7
  - Adam优化器
  - 训练20轮，批次大小128

---

### Cell 71: 评估生物+化学+人口统计学特征模型
```python
predictions = model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate macro average AUC
macro_auc = roc_auc_score(y_test, predictions, average='macro')
print(f"Macro AUC: {macro_auc}")

map_per_class = average_precision_score(y_test, predictions, average=None)
print(f"MAP per class: {map_per_class}")

# Calculate macro average MAP
macro_map = average_precision_score(y_test, predictions, average='macro')
print(f"Macro MAP: {macro_map}")
```
**解释**: 评估生物+化学+人口统计学特征组合的模型性能。

---

### Cell 72: 注释标记
```python
# molecular, chemical, and bio 
```
**解释**: 注释标记，表示使用分子+化学+生物特征（不含人口统计学）。

---

### Cell 73: 分子+化学+生物特征（网格搜索）
```python
x_train = train.loc[:, "A0A023W3H0":"880"]
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = test.loc[:, "A0A023W3H0":"880"]
y_test = test.loc[:, 'cardiac failure': "vomiting"]

# Define the model
def create_model(optimizer='adam', dropout_rate=0.5, activation='relu'):
    model = Sequential()
    model.add(Dense(512, activation=activation, input_shape=(x_train.shape[1],)))
    model.add(Dropout(dropout_rate))
    model.add(Dense(256, activation=activation))
    model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification
    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=[AUC(name='auc', multi_label=True)])
    return model

# Wrap the model using KerasClassifier
model = KerasClassifier(build_fn=create_model, epochs=10, batch_size=64, verbose=0)

# Define the parameter grid
param_grid = {
    'optimizer': ['adam', 'rmsprop'],
    'dropout_rate': [0.3, 0.5, 0.7],
    'activation': ['relu', 'tanh'],
    'batch_size': [32, 64, 128],
    'epochs': [10, 20, 100]
}

# GridSearchCV
grid = GridSearchCV(estimator=model, param_grid=param_grid, scoring='roc_auc', cv=3)
grid_result = grid.fit(x_train, y_train)

# Print the best parameters and best score
print(f"Best parameters found: {grid_result.best_params_}")
print(f"Best AUC score: {grid_result.best_score_}")

# Evaluate the best model on the test set
best_model = grid_result.best_estimator_.model
predictions = best_model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate the average AUC across all classes
average_auc = np.mean(auc_per_class)
print(f'Average AUC: {average_auc}')
```
**解释**: 组合分子、化学和生物特征（不含人口统计学），使用网格搜索优化超参数。

---

### Cell 74: 分子+化学+生物特征（固定超参数）
```python
x_train = train.loc[:, "A0A023W3H0":"880"]
y_train= train.loc[:, 'cardiac failure': "vomiting"]
x_test = test.loc[:, "A0A023W3H0":"880"]
y_test = test.loc[:, 'cardiac failure': "vomiting"]

y_test = test.loc[:, 'cardiac failure': "vomiting"]
model = Sequential()
model.add(Dense(512, activation='relu', input_shape=(x_train.shape[1],)))
model.add(Dropout(0.7))
model.add(Dense(256, activation='relu'))
model.add(Dense(30, activation='sigmoid'))  # Sigmoid activation for multi-label classification

# Compile the model with AUC as the metric
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=[AUC()])
model.fit(x_train, y_train, epochs=10, batch_size=128, validation_split=0.2)
```
**解释**: 
- **特征组合**: 分子+化学+生物特征（不含人口统计学）
- **模型配置**: 
  - Dropout 0.7
  - Adam优化器
  - 训练10轮，批次大小128
- **注意**: 有重复的`y_test`赋值，但不影响功能

---

### Cell 75: 评估分子+化学+生物特征模型
```python
predictions = model.predict(x_test)

# Calculate AUC for each class
auc_per_class = roc_auc_score(y_test, predictions, average=None)
print(f"AUC per class: {auc_per_class}")

# Calculate macro average AUC
macro_auc = roc_auc_score(y_test, predictions, average='macro')
print(f"Macro AUC: {macro_auc}")

map_per_class = average_precision_score(y_test, predictions, average=None)
print(f"MAP per class: {map_per_class}")

# Calculate macro average MAP
macro_map = average_precision_score(y_test, predictions, average='macro')
print(f"Macro MAP: {macro_map}")
```
**解释**: 评估分子+化学+生物特征组合的模型性能。

---

### Cell 76: 空单元格
```python

```
**解释**: 空单元格，代码分析结束。

---

## 总结

### 主要发现

1. **模型架构**: 使用多层感知机（MLP）神经网络，标准架构为：
   - 输入层: 特征维度
   - 第一隐藏层: 512个神经元 + Dropout
   - 第二隐藏层: 256个神经元
   - 输出层: 30个神经元（对应30个不良反应标签），sigmoid激活

2. **超参数优化**: 
   - 使用网格搜索（GridSearchCV）系统性地测试多种超参数组合
   - 搜索空间包括：优化器（Adam/RMSprop）、Dropout率（0.3/0.5/0.7）、激活函数（ReLU/tanh）、批次大小（32/64/128）、训练轮数（10/20/100）

3. **特征组合实验**: 
   - 系统性地测试了单一特征类型和多种特征组合
   - 包括：人口统计学、分子、化学、生物特征的各种组合

4. **评估指标**: 
   - 使用AUC（ROC曲线下面积）和MAP（平均精度）作为主要评估指标
   - 计算每个类别的指标和宏平均指标

### 代码结构

1. **数据预处理** (Cell 0-11): 数据加载、聚类分割、特征标准化、数据分割
2. **模型导入** (Cell 12): 导入深度学习相关库
3. **特征组合实验** (Cell 13-75): 
   - 每种特征组合都包含网格搜索和固定超参数两种实验
   - 系统性地测试了所有可能的特征组合
4. **模型评估** (Cell 17, 22, 26, 30, 34, 38, 43, 47, 51, 55, 59, 63, 67, 71, 75): 对每个模型进行性能评估

### 技术要点

- **多标签分类**: 使用sigmoid激活函数和二元交叉熵损失函数处理多标签分类问题
- **正则化**: 使用Dropout防止过拟合
- **超参数优化**: 使用网格搜索和交叉验证寻找最佳超参数
- **特征工程**: 系统性地测试不同特征组合的预测能力

### 与Modeling 1-RF的对比

1. **模型类型**: 
   - RF: 随机森林（集成学习）
   - DL: 深度学习（神经网络）

2. **特征重要性**: 
   - RF: 可以计算特征重要性
   - DL: 难以直接解释特征重要性

3. **超参数优化**: 
   - RF: 主要优化树的数量、深度等
   - DL: 优化优化器、Dropout率、激活函数、批次大小、训练轮数等

4. **计算资源**: 
   - RF: 相对较快
   - DL: 需要更多计算资源和时间

---

## 代码质量评估

### 优点
1. 完整的实验流程，从数据预处理到模型评估
2. 系统性地测试了多种特征组合
3. 使用了网格搜索进行超参数优化
4. 使用了多种评估指标（AUC和MAP）
5. 代码结构清晰，易于理解

### 可改进之处
1. 部分代码有重复（如评估代码重复多次）
2. 某些单元格缺少注释
3. 可以添加更多的数据可视化
4. 可以添加早停（Early Stopping）机制防止过拟合
5. 可以添加学习率调度器
6. Cell 74中有重复的`y_test`赋值

---

**报告生成时间**: 2024年
**代码文件**: Modeling 2-DL.ipynb
**总单元格数**: 76